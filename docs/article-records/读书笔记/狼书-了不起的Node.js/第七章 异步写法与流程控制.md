## 第七章 异步写法与流程控制

> Rong姐姐好可爱，整理于2020年11月22日


**流程控制是程序中的逻辑控制的统称，** Node.js中每个函数都是异步的，性能虽然会更好，但容易造成**callback hell（回调地狱）**，因此为了解决API级别的回调地狱问题，就需要使用的到流程控制的部分——异步流程控制

**可以这样说，掌握了Nodejs里的异步流程控制，就基本掌握了Nodejs一半以上的内容**



#### 异步与同步

> 异步执行效率更高，但结果却不一定是我们想要的，异步执行的结果具有一定的不确定性

- 异步

> 在操作中，不需要等待服务器的回复，该忙什么忙什么，不耽误事件，合理利用时间高效做事，即：充分利用服务器执行并行操作；

- 同步

> 操作必须要等待回复后才能去做其他的事情，有种至死方休的感觉。每一步都需要等待上一步完成才能进行；

例如JQuery中的ajax异步请求
```javascript
//  存在于浏览器中的异步
$.ajax({
    url:'XXXXX',
    type:'get',
    data:{
        
    },
    success:ret=>{
        // 回调函数的方式，返回结果
        console.log(ret)
    }
})
```

**Ajax的核心是XHR，即：XMLHttpRequest；Nodejs的核心是EventLoop，即：事件循环**，异步请求不需要取刷新页面就可以获取数据；

EventLoop是维护一个回调函数的**队列**，当回调函数执行时，回调函数就会被放入到这个队列中。Javascript引擎直到异步函数执行完成后，才会开始处理EventLoop，也就是说Javascript代码不是多线程的，虽然表现出来的效果是跟多线程很相似的。**EventLoop维护的是先进先出（First in First out）的队列，说明回调函数在队列中是顺序执行的**；

EventLoop依赖libuv库，而libuv库采用的是异步和事件驱动的风格，主要功能是为开发人员提供一套基于I/O通知的回调函数；



### API介绍

API:Application Programming Interface简称，异步的核心在于Nodejs SDK的API调用，然后交由EventLoop（libuv）去执行。**因此Nodejs的API操作非常重要**； [Nodejs Api官网](http://nodejs.cn/api/)


```javascript
const fs=require('fs');
// 文件路劲
const path='.'

// 异步读取

fs.readdir(path,funtion(err,files){
    if(err){
        // 出现异常
    }
    // 读取结果
    console.log(files)
})
// 也可以转换为箭头函数

fs.readdir(path,(err,files)=>{
    if(err){
        // 出现异常
    }
    // 读取结果
    console.log(files)
})


// 同步写法

const result=fs.readdirSync(path);
// 输出结果
console.log(result)
```

#####  同步和异步的简单区别

- 同步方式更容易理解，但会造成线程阻塞，无法最大限度利用系统资源；
- 异步方式需要嵌套回调，即使代码编写得非常规范也不容易理解和维护，但它能够并行执行，同时处理更多的任务，**效率更高**


**Nodejs实现了高的效率，至于是如何提升可控性则是开发人员要解决的问题，也是Nodejs体系中最难的点**


### 自带的异步写法

Nodejs中事件的处理方式：
- 回调函数(callback function)
- 事件发射器(eventEmitter)

callback function采用错误优先(error-first)的回调方式，而EventEmitter则是事件驱动里的事件发射器


错误优先回调方式的写法:

- 回调函数的第一个参数返回的是error对象（程序出错抛出来的异常），如果发生错误，该对象会作为第一个参数返回，**如果正常执行，一般返回是null，方便在下文进行if(error)判错处理**（其实只要返回是的非ture，应该不影响后续判断，不过约定俗成吧~）

- 回调函数的第二个参数返回的是所有成功响应的结果数据，如果结果正常，则没有发生错误，参数err就会被设置成null，并在第二个参数处返回成功响应的结果；


```javascript
/**
* err ：错误对象
* data ： 成功时返回的数据
*/
function (err,data){
    if(err){
        // 存在错误
    }
    // 正常，则输出结果data
    console.log(data)
}
```

但从代码语义上来说，非空的err属于程序异常，而空的err相当于能够正常返回结果，不存在异常。


##### API写法约定

- 模块应该暴露错误优先的回调接口

```javascript
module.exports=function(dragonName,callback){
    // 逻辑处理
    const dragon=createDragon(dragonName);
    
    // 注意第一个参数时error,如果没有错误，则它的默认值时null
    return callback(null,dragon);
}
```


**只有同步代码才能使用try-catch，在回调函数中不能随意使用！**经典异常捕获方法：
```javascript
const fs=require('fs');
function readJSON(filePath,callback){
    fs.readFile(filePath,function(err,data){
        const parsedJSON;
        // 错误处理
        if(err){
            return callback(err);
        }
        // 解析
        try{
            parsedJSON=JSON.parse(data)
        }catch(exception){
            return callback(exception)
        }
        
        // 无异常，返回数据
        return callback(null,parsedJSON)
    })
}

```

### EventEmitter

> 事件模块是Node.js内置的对观察者模式的实现，通过EventEmitter属性提供一个构造函数。该构造函数的实例中具有两个常用的方法，其中on方法可以用来监听指定事件，并触发回调函数，另外一个emit方法可以用来发布事件。可以通过发布订阅模型来理解；



```
graph LR
订阅-->发布
on-->emit
```

EventEmitter是Node.js的基础模块，通过EventEmitter属性建立了一个EventEmitter对象实例，即：消息中心

```javascript
const EventEmitter=require('events')
// 初始化消息中心实例
const observer=new EventEmitter();


// 订阅
observer.on('topic',()=>{
    console.log('订阅执行的方法')
})

// 发布 可以传参
observer.emit('topic')

// 声明方法调用

function main(){
    console.log('main() function start:')
    observer.emit('topic')
    console.log('main() function ending')
}

// 执行
main()

```

可以简单理解为“发布/订阅”模式，当observer调用emit方法时，所有通过on注册该topic事件的回调函数都会被调用；

EventEmitter对象的事件触发和监听时同步的，这里和前端的事件机制很类似,Vue的父组件传值，也有对应的$emit和$on的机制
```javascript
// jquery

$('#footer').on('click',function(){
    console.log('点击后的效果')
})

// 此处的trigger类似于emit，事件的触发器
$('#footer').trigger('click');


// click事件，也可以支持简写

$('#footer').click(()=>{
    console.log('点击后触发')
})

```

emit()方法用于触发事件，on()方法用于注册事件。对于on()方法而言，默认情况下，Node.js允许同一个事件最多指定10个回调函数
```javascript
event.on('someEvent',()=>{
    console.log('event 1')
})
event.on('someEvent',()=>{
    console.log('event 2')
})

......// 更多

```

当超过10个回调函数时会发出警告⚠，当然也可以通过`setMaxListeners`方法来改变
```
event.setMaxListeners(100)
```

也可以用`Infinity`来设置最大值（**Infinity用来表示无穷大**）


事件传参举例：
```javascript
const eventEmitter=require('events')
const myEmitter=new EventEmitter();

function testConnection(param){
    console.log('传递的参数'，param)
}

myEmitter.on('test',testConnection)

// 参数传递10
myEmitter.emit('test',10)
```

---

### 事件 

- 事件操作接口
> 常见有removeListener事件和newListener事件，用来移除和添加

- once方法
> 类似于on()方法，**但是对应的回调函数只能被调用一次**，而on()中的回调函数会被触发多次；

- 获取监听器信息
> 利用EventEmitter对象中的listeners()方法

- 事件错误处理



### Promise对象

**每个Promise对象都有then()方法，也就是说，then()方法是定义在原型对象Promise.protype上的，作用是为Promise实例添加状态改变时的回调函数**

```javascript
Promise.protype.then=function(success,fail){
    this.done(success);
    this.fail(fail);
    // 返回this
    return this
}
```
由于这里每个then都会**返回this对象**，因此可以一直then()下去，形成链式写法

- success: fulfilled状态的回调函数
- fail:rejected状态的回调函数

一般情况下，只需要传success回调函数即可，fail函数可选，使用catch来捕获异常比通过fail函数，请示更加好控制（这里越总结，越向jquery的ajax写法）


**任何Promise对象都必须处于pending、fulfilled、rejected其中之一的状态**

- pending：初始状态，独立于fulfilled和rejected的状态
- fulfilled: 完成（成功）状态
- rejected:拒绝（失败）状态


#### 状态切换


```
graph LR
pending-->fulfilled

```

```
graph LR
pending-->rejected

```

以上两种状态的转换都是单向的，而且fulfilled和rejected两个状态之间是不能互相转换的,最重要的是：**只有异步操作有结果的手，可能决定当前Promise处于那种状态，任何其他操作都没法改变这个状态**


### Promise的API方法
> Promise规范非常简单，只包含一个构造函数和六个方法

```javascript
// 构造函数

new Promise((resolve,reject)=>{
    
})
// 所有Promise都要通过这种方式创建， resolve和reject是唯一可以改变Promise对象状态的接口
```

- resolve可以让状态从pending切换到fulfilled
- reject可以让状态从pending切换到rejected(当然，reject是可选参数)

```javascript

Promise.protype.then() 捕获当前操作的resolve结果

Promise.protype.catch() 捕获全局操作的reject异常

```

**特别值得注意的是：resolve相当于Promise.resolve的别名，reject相当于Promise.reject的别名**。

```javascript
new Promise(resolve=>{
    resolve(1)
}).then(ret=>{
    console.log('resolve传递值：',ret)
})
// 类似于别名
Promise.resolve(1).then(ret=>{
    console.log('resolve传递值：',ret)
})
```

总结一下，6个内置方法：

- Promise.resolve()
> 可以看作：Promise.protype.resolve(),方法后面可以跟then()方法

- Promise.reject()
> 可以看作：Promise.protype.reject()，方法后面可以跟catch()方法

- Promise.protype.then()
> 语法：
p.then(onFilfilled,onRejected) 或者p.then(value=>{.............})。
此处onRejected一般省略

- Promise.protype.catch()
> 语法：
p.catch(onRejected) 或者p.catch(error=>{.............})

- Promise.all()
> 在所有接收到的Promise对象都变为fulfilled或者rejected状态之后才会继续进行后面的处理【**多个方法之间并行处理**】

- Promise.race()
>  只要有一个Promise对象进入fulfilled或者rejected状态，就会继续后面的处理【**多个方法之间并行处理**】


##### Promise化

在Javascript中，不是所有的异步函数和库都支持开箱即用的Promise,在大多数情况下，必须将一个典型的基于回调的函数转换成一个返回Promise的函数，这个过程为**promisification**

- promisefy
- promisefyAll

以上两个api都是基于`bulebird`模块的

```javascript
const Promise =require('bluebird')

const fs=Promise.promisifyAll(require('fs'))

const obj={
    a:()=>{
        console.log('function a')
    },
    b:()=>{
        console.log('function b')
    },
    c:()=>{
        console.log('function c')
    }
}
// 全部转化为同步

Promise.promisifyAll(obj)

// 调用
obj.aAsync().then(obj.bAsync()).then(obj.cAsync()).catch(err=>{
    // 处理
})
```
说一点：promisifyAll可能有性能问题


**当然，这里来源于`bluebird`模块的Promise对象，其实是具备Nodejs的Promise对象的所有构造函数和属性，兼容所有原生所有版本的**

----

### 异常处理

异常处理是异步流程控制里最难的部分，异常主要分为两种，系统错误和程序员错误。系统错误有：
- 请求超时
- 内存不足
- 连接远程服务失败等

一般需要搭配系统监控等辅助软件解决。

程序员错误即程序的Bug，产生的原因很多，比如：
- 在调用异步方法时没有使用回调
- 无法读取undefined的属性
- 在高并发的场景下使用了同步阻塞代码
- 没有及时处理异常
- 内存泄漏

这类错误是可以避免的，应对的主要方法是启动服务，通过日志记录一切；


开发者都遵守一样的约定能够有效的降低沟通成本，写法越底层，使用者越有可发挥的空间；

在Nodejs的世界里，http是最常用的模块，它简单且效率非常高，是被应用最广泛的模块。如果说http是Node.js的核心模块，那么Stream就是核心中的核心，是保证http高效的秘密武器。相比之下，events显得极为底层，是为核心模块服务的；
