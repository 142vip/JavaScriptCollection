
## 模块与核心

> Rong姐姐好可爱，整理于2020年11月20日



### Node.js和CommonJS的区别(主要体现在module.exports)：

- Node.js中，module.exports是真正的特殊对象，是真正的对外暴露出口，而exports只有一个变量，是被默认的module.exports版绑定的
- CommonJS规范里灭有module.exports对象。


exports是一个特殊的对象，它的任何输出都将作为一个对外暴露的公共API

```javascript
// 导出演示

const PI=Math.PI

exports.PI=PI


// 引入演示

const PI=require('XXX')

```

特别注意的是：当module.exports和exports对象同时存在时，以module.exports为准

```javascript
exports=()=>{
    return {
        a:123
    }
}

module.exports=()=>{
    return {
        a:123
    }
}

// 此时，只有module.exports有效

```

总结来说，在CommonJs规范里面没有module.exports对象，一般用exports对象和required来处理模块的导出和引入

在Node.js中exports、module.exports、require是都存在的，exports对象和module.exports对象都能实现模块导出，但是module.exports优先级更高；模块的导入都用require进行处理；



### 核心技术

Node.js对模块的定义非常简单，主要分为模块应用、模块定义和模块标识三个部分。

##### require

> 用来引用模块

##### export 
> 用来导出模块，包括标识符(identifier)和模块内容(contents)

- module.exports 对外导出的对象只能有一个
- exports.XXX  对外导出的值可以有多个，并且两者同时存在时，exports无效，module.exports的优先级更高；



#### 模块定义

> 可以将关联代码封装到一个代码单元中，创建一个模块可以理解为全部有关联的函数放在一个文件中

```javascript
const sayHelloEnglish=function(){
    return 'hello'
}

module.exports={
    sayHelloEnglish
}
```

#### 模块导出

```
graph LR
exports-->module.exports

module.exports-->exports
```

**核心是module.exports，exports对象只是module.exports的一个引用**
```javascript

// 变量引用
const exports=module.exports={}

```

```javascript
exports.sayHelloInChinese=()=>{
    return '你好'
}


exports.sayHelloInEnglish=()=>{
    return 'Hello'
}
```


```javascript  
module.exports={
    sayHelloInEnglish:()=>{
        return 'Hello';
    },
    sayHelloInChinese:()=>{
        return '你好'
    }
}

```

从上面可以看到:

- exports可以用飙血多个对外暴露的API工具类代码
- module.exports用于比那些对外暴露同一个对象API的代码


**核心是module.exports，exports对象只是module.exports的一个引用**


#### 模块引用

直接用require进行引用，对结果进行赋值，对于module.exports导出的结果对象，引用的时候可以解构赋值给新对象






module.exports不一定非要返回实例化对象

```javascript

module.exports=1
module.exports=NaN
// 导出字符串
module.exports='foo'
// 导出对象
module.exports={foo:'bar'}
// 导出数组
module.exports=['foot','bar']
// 导出函数方法
module.exports=()=>{
    
}
...

```

这里总结一下：

- 如果希望模块是一个特定的类型，可以用module.exports
- 如果希望模块是典型的实例化类型，可以用exports

给module.exports添加属性类似给exports添加属性，exports可以看作是module.exports的一个引用；

```javascript
module.exports.name=()=>{
    console.log('My name is Lemmy Kilmister ')
}

exports.name=()=>{
    console.log('My name is Lemmy Kilmister ')
}
```

**上面的结果并不相同**，module.exports是真正的接口，exports只是module.exports的辅助辅助工具；


在默认情况下，module.exports的返回值是空对象，如果只是添加方法和属性，只要操作具体的exports即可；只有当你不希望返回值是对象就可以用module.exports对他的属性进行处理；

**exports是形参数，只能在作用域内改变，出了作用域就会被还原，所以想要覆盖对外导出返回值时需要使用module.exports**

推荐最佳写法

```javascript
exports=module.exports=opts=>{
    // 除了工具类用exports.xxxx 其他都建议用module.exports
    ....
}

```


####  理解模块的引用

Node.js模块分为：

- 核心模块
- 文件模块

引入模块，使用require()方法，它可以接受的参数有：

- 像http、fs、path等Node.js的内置模块
- ./mod或者../file.js：类似采用相对路径的文件模块
- /path/file.js: 类似采用绝对路劲引入的模块
- mod ：非原生模块的文件模块


#### 加载方式

- 直接使用名字加载
- 查找node_module目录来加载
- 使用全局安装的模块来加载



### 全局对象

模块的两种写法：
- 基于CommonJS规范来实现，也就是常说的module.exports
- 全局对象写法，不需要引入，直接通过全局对象进行使用；

#### 内置对象

在Nodejs中有一批内置对象，无需安装即可使用的模块，不需要依赖global关键字

##### 第一类 为模块包装提供的全局对象

- exports： CommonJS关键字
- require： CommonJS关键字
- module： CommonJS关键字
- _filename： 当前文件名称
- _dirname：当前文件目录


##### 第二类 内置process对象

> process为核心模块，可以在当前Nodejs的各种信息进行绑定,Java8中也有类似的思想

##### 第三类 控制台Console模块

> 比如：console.log(),console.info()... 跟JavaScript里面不一样的是，Nodejs里面的可以在终端中输出，而Javascript中的会在浏览器的控制台进行输出


##### 第四类 Event Loop相关Api的实现

- setImmediate(callback[,...args])
- setInterval(callback,delay[,...args])

- setTimeout(callback,delay[,...args])
- clearImmediate(immediateObject)
- clearInterval(intervalObject)
- clearTimeout(timeoutObject)

Event Loop用全局对象来实现是非常方便的;


##### 第五类 Buffer对象

-  new Buffer()
-  Buffer.from() ： 推荐使用
-  Buffer.alloc() ：推荐使用
-  Buffer.allocUnsafe()： 存在内存泄漏
-  Buffer.allocUnsafeSlow()： 存在内存泄漏



Nodejs中的全局对象和Javascript里的普通对象是一样的，主要是用来拓展变量和方法的；


扩展变量：
```javascript

// 扩展debug变量，并进行加载
global.debug=true;

// 使用扩展的debug变量
if(debug===true){
    .....
    
}

```

扩展方法：

```javascript

// log方法扩展

global.log=console.log

// 等价使用console.log('something')
log('something')


```

#### ES模块

> ES模块的新特性往往引人入胜，ES模块的目标是创建一个同时兼容CommonJS和AMD的格式，使语法更加的紧凑，通过编译时加载，在编译时就能够确定模块的依赖关系，比CommonJS模块的加载效率更高。而在异步加载和配置模块加载方面，从执行效率、灵活度来看都优于CommonJS语法

ES模块的优势：

- 语法紧凑

- 解构更加适用于静态编译（例如：静态类型检查、优化）
- 对循环引用的支持更好
- 用法简单，不需要关注实现细节
- 采用声明式语法：模块中导入用import关键字，导出用export关键字，没有require关键字。
- 程式化加载API：可以设置模块如何加载，并按需加载



##### 模块导入


```
// 直接导入，并取名fs 与CommonJS中的const fs=require('fs')类似
import * as fs from 'fs'

// 按需导入
import {readFile} from 'fs'

```


**此时按需导入只加载readFile方法，不加载其他，这种加载叫做编译时加载或者静态加载能够让ES6在编译时完成模块加载，效率更高**

##### 模块导出

```javascript

// 对所有内容进行导出
export * from 'XXXXX'

// 按照需要进行导出
export {foot as foot_copy,bar} from 'XXXX'

```

注意as的使用，有时候为了代码方便，别名是非常有必要的


###### 具名导出
> 导出对象的指定别名的过程叫做具名导出

```javascript
export {MY_CONST as FOO,myFunc};

export {foot as test}

```

###### 内联具名导出

> 变量的声明有多种，在内联具名导出时不会受到限制

```javascript

// 导出var定义的foo变量
export var foo;
// 导出const定义的woo变量
export const woo;
// 导出let定义的test变量
export let test;

```

函数也可以类似变量进行导出

```javascript
export function myFunc(){
    // 处理逻辑
    ....
}

export function* myGenFunc(){
    // 处理逻辑
    ....
}

// function* 这种声明方式(function关键字后跟一个星号）会定义一个
// 生成器函数 (generator function)，它返回一个  Generator  对象。

```

```javascript

export class MyClass{
    // 类实现
    ...
}

```

###### 默认导出

> 即用default关键字，在引用时默认返回导出对象
> 
> 值得注意的是：

```javascript

export default function myFunc(){
    // 
    ...
}

export default function(){
    //
    ...
}

// 默认导出生成器函数，返回generator函数
export default function* myGenFunc(){
    
    ...
}

export default function* (){
    // 
    ...
}

// 默认导出MyClass类
export default class MyClass{
    // 类实现
    ...
}

// 默认导出匿名类
export default class{
    //
    ...
}


// 当然，其他的也是可以的

export default foo;
export default 'Hello World';
export default 3*7;
// 匿名函数
export default (function(){});

```

### export default和export的区别

- **export default 向外暴露的成员，可以使用任意的变量来接收**
- **在一个模块中，export default 只允许向外暴露1次**
- 在一个模块中，可以同时使用 export default 和 export 向外暴露成员
- 使用 export 向外暴露的成员，只能使用 { } 的形式来接收;
- export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以 不在 {} 中定义
- 使用 export 导出的成员，必须严格按照导出时候的名称，来使用 {} 按需接收；
- 使用 export 导出的成员，如果就想换个名称来接收，可以使用 as 来起别名；