# 表模型

模型是通过官方文档中Model一词，直接翻译过来，在使用ORM框架去操作数据库的时候，**模型是 Sequelize 的本质. 模型是代表数据库中表的抽象.
在 Sequelize 中，它是一个 Model 的扩展类.** 模型往往和表字段是一一对应的，这样非常利于封装，类似于Java中的MyBatis。

这部分主要包含：

- 模型基础
- 模型实例

相比官方文档的详细、全面，这里主要从实用出发，总记一套完整、基础、易于上手的模型笔记文档，开始吧~

## 模型定义

在 `Sequelize` 中可以用两种等效的方式定义模型：

- 调用 `sequelize.define(modelName, attributes, options)`
- 扩展 `Model` 并调用 `init(attributes, options)`

**在内部，`sequelize.define` 调用 `Model.init`，因此两种方法本质上是等效的.**

定义模型后，可通过其模型名称在 `sequelize.models` 中使用该模型.

例如，创建一个代表用户的模型，该模型具有一个 `firstName` 和一个 `lastName`. 我们希望将模型称为 `User`
，并将其表示的表在数据库中称为 `Users`.

定义该模型的两种：

## 使用`sequelize.define`

```js
// 直接使用sequelize缓存封装，方便举例
const {Sequelize, DataTypes} = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const User = sequelize.define('User', {
  // 在这里定义模型属性
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull 默认为 true
  }
}, {
  // 这是其他模型参数
});

// `sequelize.define` 会返回模型
console.log(User === sequelize.models.User); // true
```

## 扩展 `Model`

```js
const {Sequelize, DataTypes, Model} = require('sequelize');
const sequelize = new Sequelize('sqlite::memory');

class User extends Model {
}

User.init({
  // 在这里定义模型属性
  firstName: {
    type: DataTypes.STRING,
    allowNull: false
  },
  lastName: {
    type: DataTypes.STRING
    // allowNull 默认为 true
  }
}, {
  // 这是其他模型参数
  sequelize, // 我们需要传递连接实例
  modelName: 'User' // 我们需要选择模型名称
});

// 定义的模型是类本身
console.log(User === sequelize.models.User); // true
```

定义后,我们可以使用 `sequelize.models.User` 访问模型.

## 表名规则

上面两种方法的模型定义中,都未明确定义表名(`Users`). 但是,给出了模型名称(`User`).

默认情况下,当**未提供表名时,Sequelize 会自动将模型名复数并将其用作表名.**
这种复数是通过称为 [inflection](https://www.npmjs.com/package/inflection) 的库在后台完成的,因此可以正确计算不规则的复数(
例如 `person -> people`).

### 强制表名称等于模型名称

可以使用 `freezeTableName: true` 参数停止 `Sequelize` 执行自动复数化. 这样,`Sequelize` 将推断表名称等于模型名称,而无需进行任何修改：

```js
sequelize.define('User', {
  // ... (属性)
}, {
  freezeTableName: true
});
```

上面的示例将创建一个名为 `User` 的模型,该模型指向一个也名为 `User` 的表.

```js
// sequelize 实例全局定义 强制表名称等于模型名称
const sequelize = new Sequelize('sqlite::memory:', {
  define: {
    freezeTableName: true
  }
});
```

这样全局定义后,所有表将使用与模型名称相同的名称.

### 直接提供表名

直接告诉 `Sequelize` 表名称：

> 建议数据库表名以tbl开头，例如： tbl_user_list

```js
// tableName指定表名
sequelize.define('User', {
  // ... (属性)
}, {
  tableName: 'Employees'
});
```

## 同步模型

定义模型时,要告诉 `Sequelize` 有关数据库中表的一些信息. 但是:

- 如果该表实际上不存在于数据库中怎么办？

- 如果存在,但具有不同的列,较少的列或任何其他差异,该怎么办？

这两种情况，都是预期情况与实际情况产生差异时，会经常存在的。同时，这也是模型同步的来源.

可以通过调用一个异步函数(返回一个Promise)`model.sync(options)`.  **`Sequelize` 将自动对数据库执行 SQL 查询.**

特别注意：**这仅更改数据库中的表,而不更改 JavaScript 端的模型.**+

- `User.sync()` - 如果表不存在,则创建该表(如果已经存在,则不执行任何操作)
- `User.sync({ force: true })` - 将创建表,如果表已经存在,则将其首先删除
- `User.sync({ alter: true })` - 这将检查数据库中表的当前状态(它具有哪些列,它们的数据类型等),然后在表中进行必要的更改以使其与模型匹配.

```js

await User.sync({force: true});

await User.sync({force: false, alter: true})

```

### 一次同步所有模型

可以使用 `sequelize.sync()` 自动同步所有模型. 示例：

```js
await sequelize.sync({force: true});
console.log("所有模型均已成功同步.");
```

`sync({ force: true })` 和 `sync({ alter: true })` 可能是破坏性操作（**一旦输出数据库，只能通过数据库日志进行恢复**）.
因此,不建议将它们用于生产级环境中.

### 删除表

```js
// 删除单个表，例如：User
await User.drop();

// 删除所有表
await sequelize.drop();

```

注意：

- 删除单个表时，是对应表的模型对象调用drop()方法实现。

- 删除所有表时，是当前连接的sequelize实例调用drop()方法实现。

## 时间戳的使用

**默认情况下,`Sequelize` 使用数据类型 `DataTypes.DATE` 自动向每个模型添加 `createdAt` 和 `updatedAt` 字段.**

使用`Sequelize` 创建或更新内容时,字段都会被自动设置.

- `createdAt` 字段将包含代表创建时刻的时间戳

- `updatedAt` 字段将包含最新更新的时间戳.

**特别需要注意的是：上面的字段自动管理实在在 Sequelize 级别完成的(即未使用 *SQL触发器* 完成)**.

**直接 SQL 查询(例如,通过任何其他方式在不使用 Sequelize 的情况下执行的查询)将不会导致这些字段自动更新.**

```js
// 配置单个表的字段自动管理
sequelize.define('User', {
  // ... (属性)
}, {
  // 是否禁用字段自动管理
  timestamps: false
});
```

也可以只启用 `createdAt`/`updatedAt` 之一,并为这些列提供自定义名称：

```js
class Foo extends Model {
}

Foo.init({
  // ... (属性)
}, {
  sequelize,
  // 这里时间戳必须启用true
  timestamps: true,
  // 不使用createdAt字段
  createdAt: false,
  // 使用 updatedAt字段 但是希望名称叫做 create_time
  updatedAt: 'create_time'
});
```

## 表字段简写

如果关于列的唯一指定内容是其数据类型,可以缩短语法：

```js
// 指定字段name的数据类型
sequelize.define('User', {
  name: {
    type: DataTypes.STRING
  }
});

// 简写
sequelize.define('User', {name: DataTypes.STRING});

```

## 默认值

默认情况下,`Sequelize` 假定列的默认值为 `NULL`. 可以通过将特定的 `defaultValue` 传递给列定义来更改此行为：

```js
sequelize.define('User', {
  name: {
    // string类型
    type: DataTypes.STRING,
    defaultValue: "lisa"
  }
});
```

一些特殊的值,例如 `Sequelize.NOW`,也可以正常使用：

```js
sequelize.define('Foo', {
  bar: {
    // datatime类型
    type: DataTypes.DATETIME,
    // 当前日期/时间
    defaultValue: Sequelize.NOW
  }
});
```

## 列参数

在定义列时,除了指定列的 `type`、`allowNull` 和 `defaultValue` 参数外,还有很多可用的参数. 下面是一些示例.

```js

// 引入模块并解构
const {Model, DataTypes, Deferrable} = require("sequelize");

class Foo extends Model {
}

Foo.init({
  // 实例化将自动将 flag 设置为 true (如果未设置)
  flag: {type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true},

  // 日期的默认值 => 当前时间
  myDate: {type: DataTypes.DATE, defaultValue: DataTypes.NOW},

  // 将 allowNull 设置为 false 将为该列添加 NOT NULL,
  // 这意味着如果该列为 null,则在执行查询时将从数据库引发错误.
  // 如果要在查询数据库之前检查值是否不为 null,请查看下面的验证部分.
  title: {type: DataTypes.STRING, allowNull: false},

  // 创建两个具有相同值的对象将引发错误.
  // unique 属性可以是布尔值或字符串.
  // 如果为多个列提供相同的字符串,则它们将形成一个复合唯一键.
  uniqueOne: {type: DataTypes.STRING, unique: 'compositeIndex'},
  uniqueTwo: {type: DataTypes.INTEGER, unique: 'compositeIndex'},

  // unique 属性是创建唯一约束的简写.
  someUnique: {type: DataTypes.STRING, unique: true},

  // 继续阅读有关主键的更多信息
  identifier: {type: DataTypes.STRING, primaryKey: true},

  // autoIncrement 可用于创建 auto_incrementing 整数列
  incrementMe: {type: DataTypes.INTEGER, autoIncrement: true},

  // 你可以通过 'field' 属性指定自定义列名称：
  fieldWithUnderscores: {type: DataTypes.STRING, field: 'field_with_underscores'},

  // 可以创建外键：
  bar_id: {
    type: DataTypes.INTEGER,

    references: {
      // 这是对另一个模型的参考
      model: Bar,

      // 这是引用模型的列名
      key: 'id',

      // 使用 PostgreSQL,可以通过 Deferrable 类型声明何时检查外键约束.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // 参数:
      // - `Deferrable.INITIALLY_IMMEDIATE` - 立即检查外键约束
      // - `Deferrable.INITIALLY_DEFERRED` - 将所有外键约束检查推迟到事务结束
      // - `Deferrable.NOT` - 完全不推迟检查(默认) - 这将不允许你动态更改事务中的规则
    }
  },

  // 注释只能添加到 MySQL,MariaDB,PostgreSQL 和 MSSQL 的列中
  commentMe: {
    type: DataTypes.INTEGER,
    comment: '这是带有注释的列'
  }
}, {
  sequelize,
  modelName: 'foo',

  // 在上面的属性中使用 `unique: true` 与在模型的参数中创建索引完全相同：
  indexes: [{unique: true, fields: ['someUnique']}]
});
```
