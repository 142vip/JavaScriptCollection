---
title: 表模型
permalink: /manuscripts/server-end/orm/sequelize/db-model.html
---

# 表模型

在使用ORM框架去操作数据库的时候，**模型是 `Sequelize` 的本质。模型是代表数据库中表的抽象。
在 `Sequelize`框架中，模型是一个 `Model` 的扩展类。**

模型往往和表字段是一一对应的，这样非常利于封装，类似于 `Java` 语言中的`MyBatis`。

## 模型定义

在 `Sequelize`框架中可以用两种等效的方式定义模型：

- 调用 `sequelize.define(modelName, attributes, options)`
- 扩展 `Model` 并调用 `init(attributes, options)`

**在内部，`sequelize.define` 调用 `Model.init`，因此两种方法本质上是等效的。**

模型的定义最重要是与表中的列要做到`关系映射`，例如：

定义一个基础的用户表的模型
@[code js](@code/orm/sequelize/db-curd-demo/db/user.js)

## 使用define()函数

@[code js](@code/orm/sequelize/db-curd-demo/db/user-define.js)

模型定义后，可以在使用挂载在`sequelize`对象上的模型实例`sequelize.models.User`。

## 使用init()函数

@[code js](@code/orm/sequelize/db-curd-demo/db/user-init.js)

定义后，我们可以使用 `sequelize.models.User` 访问模型。

## 表名规则

上面两种方法的模型定义中，都未明确定义表名(`users`)。 但是，给出了模型名称(`User`)。

**默认情况下，当未提供表名时，`Sequelize`框架会自动将`模型名复数`用作表名。**

### 强制表名等于模型名

可以使用 `freezeTableName: true` 配置， `Sequelize`框架将自动执行模型名的复数形式， 推断出`表名称`等于`模型名称`
，不需要进行任何修改。例如：

```js
const {Sequelize} = require('sequelize')
const sequelize = new Sequelize('postgres://user:pass@142vip.cn:5432/142vip')

sequelize.define('User', {
  // ... (属性)
}, {
  // 强制表名等于模型名
  freezeTableName: true
});
```

上面代码将创建一个名为 `User` 的模型，该模型指向一个也名为 `users` 的表。Sequelize框架也支持全局配置这个参数，只需要在创建sequelize连接实例时指定，例如：

```js
const {Sequelize} = require('sequelize')

const sequelize = new Sequelize('postgres://user:pass@142vip.cn:5432/142vip', {
  define: {
    // 强制所有表名称等于模型名称
    freezeTableName: true
  }
});
```

### 直接提供表名

对于模型与表之间的映射关系，本质是需要告诉Sequelize框架对应的数据库名称。 除了强制对模型名称进行转换，
还可以在模型定义式直接指定表名，使用`tableName`参数进行配置。例如：

> 建议数据库表名以tbl开头，例如： tbl_user

```js
const {Sequelize} = require('sequelize')
const sequelize = new Sequelize('postgres://user:pass@142vip.cn:5432/142vip')

sequelize.define('User', {
  // ... (属性)
}, {
  // 指定对应的表名
  tableName: 'tbl_user'
});
```

此时，在`freezeTableName`参数默认为`false`。

## 同步模型

定义模型时，要告诉 `Sequelize` 有关数据库中表的一些信息。 但是：

- 如果该表实际上不存在于数据库中怎么办？
- 如果存在，但具有不同的列，较少的列或任何其他差异，该怎么办？

这两种情况，都是预期情况与实际情况产生差异时，会经常存在的。同时，这也是模型同步的来源.

可以通过调用一个异步函数(返回一个Promise)`model.sync(options)`。  **`Sequelize` 将自动对数据库执行 SQL 查询.**

特别注意：**这仅更改数据库中的表，而不更改 JavaScript 端的模型.**+

- `User.sync()` - 如果表不存在，则创建该表(如果已经存在，则不执行任何操作)
- `User.sync({ force: true })` - 将创建表，如果表已经存在，则将其首先删除
- `User.sync({ alter: true })` - 这将检查数据库中表的当前状态(它具有哪些列，它们的数据类型等)，然后在表中进行必要的更改以使其与模型匹配.

```js
await User.sync({force: true});

await User.sync({force: false, alter: true})
```

### 一次同步所有模型

可以使用 `sequelize.sync()` 自动同步所有模型。 示例：

```js
await sequelize.sync({force: true});
console.log("所有模型均已成功同步.");
```

`sync({ force: true })` 和 `sync({ alter: true })` 可能是破坏性操作（**一旦输出数据库，只能通过数据库日志进行恢复**）.
因此,不建议将它们用于生产级环境中.

### 删除表

```js
// 删除单个表，例如：User
await User.drop();

// 删除所有表
await sequelize.drop();
```

注意：

- 删除单个表时，是对应表的模型对象调用drop()方法实现。
- 删除所有表时，是当前连接的sequelize实例调用drop()方法实现。

## 时间戳的使用

**默认情况下,`Sequelize` 使用数据类型 `DataTypes.DATE` 自动向每个模型添加 `createdAt` 和 `updatedAt` 字段.**

使用`Sequelize` 创建或更新内容时，字段都会被自动设置

- `createdAt` 字段将包含代表创建时刻的时间戳
- `updatedAt` 字段将包含最新更新的时间戳.

**特别需要注意的是：上面的字段自动管理实在在 `Sequelize` 级别完成的(即未使用 *SQL触发器* 完成)**.

**直接 `SQL` 查询(例如,通过任何其他方式在不使用 `Sequelize` 的情况下执行的查询)将不会导致这些字段自动更新.**

```js
// 配置单个表的字段自动管理
sequelize.define('User', {
  // ... (属性)
}, {
  // 是否禁用字段自动管理
  timestamps: false
});
```

也可以只启用 `createdAt`/`updatedAt` 之一,并为这些列提供自定义名称：

```js
class Foo extends Model {
}

Foo.init({
  // ... (属性)
}, {
  sequelize,
  // 这里时间戳必须启用true
  timestamps: true,
  // 不使用createdAt字段
  createdAt: false,
  // 使用 updatedAt字段 但是希望名称叫做 create_time
  updatedAt: 'create_time'
});
```

## 表字段简写

如果关于列的唯一指定内容是其数据类型,可以缩短语法：

```js
// 指定字段name的数据类型
sequelize.define('User', {
  name: {
    type: DataTypes.STRING
  }
});

// 简写
sequelize.define('User', {name: DataTypes.STRING});
```

## 默认值

默认情况下,`Sequelize` 假定列的默认值为 `NULL`。 可以通过将特定的 `defaultValue` 传递给列定义来更改此行为：

```js
sequelize.define('User', {
  name: {
    // string类型
    type: DataTypes.STRING,
    defaultValue: "lisa"
  }
});
```

一些特殊的值,例如 `Sequelize.NOW`，也可以正常使用：

```js
sequelize.define('Foo', {
  bar: {
    // datatime类型
    type: DataTypes.DATETIME,
    // 当前日期/时间
    defaultValue: Sequelize.NOW
  }
});
```

## 列参数

在定义列时,除了指定列的 `type`、`allowNull` 和 `defaultValue` 参数外,还有很多可用的参数。 下面是一些示例.

```js
const {Model, DataTypes, Deferrable} = require("sequelize");

class Foo extends Model {
}

Foo.init({
  // 实例化将自动将 flag 设置为 true (如果未设置)
  flag: {type: DataTypes.BOOLEAN, allowNull: false, defaultValue: true},

  // 日期的默认值 => 当前时间
  myDate: {type: DataTypes.DATE, defaultValue: DataTypes.NOW},

  // 将 allowNull 设置为 false 将为该列添加 NOT NULL,
  // 这意味着如果该列为 null,则在执行查询时将从数据库引发错误.
  // 如果要在查询数据库之前检查值是否不为 null,请查看下面的验证部分.
  title: {type: DataTypes.STRING, allowNull: false},

  // 创建两个具有相同值的对象将引发错误.
  // unique 属性可以是布尔值或字符串.
  // 如果为多个列提供相同的字符串,则它们将形成一个复合唯一键.
  uniqueOne: {type: DataTypes.STRING, unique: 'compositeIndex'},
  uniqueTwo: {type: DataTypes.INTEGER, unique: 'compositeIndex'},

  // unique 属性是创建唯一约束的简写.
  someUnique: {type: DataTypes.STRING, unique: true},

  // 继续阅读有关主键的更多信息
  identifier: {type: DataTypes.STRING, primaryKey: true},

  // autoIncrement 可用于创建 auto_incrementing 整数列
  incrementMe: {type: DataTypes.INTEGER, autoIncrement: true},

  // 你可以通过 'field' 属性指定自定义列名称：
  fieldWithUnderscores: {type: DataTypes.STRING, field: 'field_with_underscores'},

  // 可以创建外键：
  bar_id: {
    type: DataTypes.INTEGER,

    references: {
      // 这是对另一个模型的参考
      model: Bar,

      // 这是引用模型的列名
      key: 'id',

      // 使用 PostgreSQL,可以通过 Deferrable 类型声明何时检查外键约束.
      deferrable: Deferrable.INITIALLY_IMMEDIATE
      // 参数:
      // - `Deferrable.INITIALLY_IMMEDIATE` - 立即检查外键约束
      // - `Deferrable.INITIALLY_DEFERRED` - 将所有外键约束检查推迟到事务结束
      // - `Deferrable.NOT` - 完全不推迟检查(默认) - 这将不允许你动态更改事务中的规则
    }
  },

  // 注释只能添加到 MySQL,MariaDB,PostgreSQL 和 MSSQL 的列中
  commentMe: {
    type: DataTypes.INTEGER,
    comment: '这是带有注释的列'
  }
}, {
  sequelize,
  modelName: 'foo',
  // 在上面的属性中使用 `unique: true` 与在模型的参数中创建索引完全相同：
  indexes: [{unique: true, fields: ['someUnique']}]
});
```
