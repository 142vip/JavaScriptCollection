---
title: 简单工厂模式
permalink: /manuscripts/server-end/design-patterns/simple-factory-mode.html
---

# 简单工厂模式

`简单工厂模式`又叫`静态工厂方法`，由一个工厂对象决定创建某一种对象类的实例，这种类型的设计模式属于创建型模式。

在`工厂模式`的大类中，具体有三个小的子类模式：

- `简单工厂模式`
- `工厂方法模式`
- `抽象工厂模式`

**`简单工厂模式`并不属于 23 种经典的设计模式，更多地被视为一种编程习惯或基础模式**，但对于理解另外两种设计模式却有重要作用

在`简单工厂模式`中，可以根据参数的不同返回不同类的实例，`简单工厂模式`专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

## 基本介绍

`简单工厂模式`目的是定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到工厂方法中进行，
主要解决接口选择的问题，让其子类实现工厂接口，返回的也是一个抽象的产品。

### 模式结构

- `Factory`: 工厂角色，工厂角色负责实现创建所有实例的内部逻辑。
- `Product`: 抽象产品角色，抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。
- `ConcreteProduct`: 具体产品角色，具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

### 优点VS缺点

优点：

工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅消费产品，`简单工厂模式`
通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。

- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过`简单工厂模式`
  可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

缺点：

- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用`简单工厂模式`将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- `简单工厂模式`由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

## 代码实现

定义一个 `Product` 接口，表示产品的通用操作方法。
具体产品类 `ConcreteProductA` 和 `ConcreteProductB` 实现了 `Product` 接口，分别表示不同类型的产品，并实现了自己的操作方法。

`SimpleFactory` 是简单工厂类，负责根据客户端的需求创建具体的产品对象。它提供了一个 `createProduct`
方法，根据传入的类型参数来创建相应的产品对象。如果传入的类型参数不合法，则抛出一个错误。

首先创建一个 `SimpleFactory` 对象 `factory`。然后，通过调用 `factory` 的 `createProduct` 方法来创建具体的产品对象。

- 创建 `productA` 对象后，调用 `operation` 方法，输出 `ConcreteProductA operation.`
- 创建 `productB` 对象后，调用 `operation` 方法，输出 `ConcreteProductB operation.`

### TypeScript

@[code ts](@code/design-patterns/简单工厂模式/SimpleFactoryPattern.ts)

### Java

@[code ts](@code/design-patterns/简单工厂模式/SimpleFactoryPattern.java)

### C语言

@[code ts](@code/design-patterns/简单工厂模式/SimpleFactoryPattern.c)

### C++

@[code ts](@code/design-patterns/简单工厂模式/SimpleFactoryPattern.cpp)

## 总结

- 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。

- `简单工厂模式`又称为静态工厂方法模式，它属于类创建型模式。在`简单工厂模式`中，可以根据参数的不同返回不同类的实例。

- `简单工厂模式`包含三个角色：
  - 工厂角色负责实现创建所有实例的内部逻辑；
  - 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；
  - 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
