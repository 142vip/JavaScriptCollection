---
title: 设计模式
permalink: /manuscripts/server-end/design-patterns
---

# 设计模式

编程语言的本质都是字符，当我们为字符赋予特性含义时，便产生了`javascript`、`c++`、`java`等不同的程序语言

## 什么是设计模式？

解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，是可以反复使用的。

## 为什么要学习设计模式？

在弄清楚为什么要学习设计模式之前，先思考什么才是高质量的代码，高质量代码的特点：

- `Bug少`
- `健壮性良好`
- `易测试`
- `易阅读`
- `易扩展`
- `性能高`

开发出高质量代码的重要方式就是遵守前人总结的7大设计原则：

- `开闭原则`：要对扩展开放，对修改关闭
- `迪米特法则`：要降低耦合度
- `里氏替换原则`：不要破坏继承体系
- `依赖倒置原则`：要面向接口编程
- `单一职责原则`：实现类要职责单一
- `接口隔离原则`：在设计接口的时候要精简单一
- `合成复用原则`：要优先使用组合或者聚合关系复用，少用继承关系复用

**开闭原则是总纲，它指导我们要对扩展开放，对修改关闭；单一职责原则指导我们实现类要职责单一；
里氏替换原则指导我们不要破坏继承体系；依赖倒置原则指导我们要面向接口编程；接口隔离原则指导我们在设计接口的时候要精简单一；迪米特法则指导我们要降低耦合
**

那么，设计原则与设计模式的关系又是什么样的呢？

好的程序需要靠7大设计原则完成，但是由于语言的缺陷导致程序需要按照一定复杂度的步骤去实现这些设计原则，而这些步骤通常都是固定的，
就像武功中的套路招式一样，如果再给这些套路加上好听的名字，这就成了设计模式。
也就是说23种设计模式就是7大设计原则在某些语言的具体实现的一种方式，每个设计模式的背后我们都能找到其依靠的一种或多种设计原则。
也就是说：**只要写代码遵循设计原则，代码就会自然而然变成了某些设计模式。**

由于现实问题的复杂性，往往导致代码不可能同时满足所有的设计原则，甚至要违背部分设计原则，这里就会有一个最佳实践的问题了。
而设计模式就为解决特定问题提供了最佳实践方案，以至于学习了设计模式后，在遇到特定问题时，很容易知道如何在满足设计原则最优解的基础上实现代码的编写。

**虽然设计原则为开发出高质量代码指明了方向，但没有对程序的高性能等做出指示，而设计模式在这方面做了补充。**

总结一下：

- 为实现设计原则的招式统一命名；
- 为特定场景问题的提供最优解决方案；
- 补充了设计原则在构建高性能程序等方面的内容。
- 设计模式通过写代码的形式帮助我们更好地学习理解设计原则，以实现高质量代码；

## 解耦与高质量代码之间的关系

解耦（低耦合）在某个角度上说属于高质量代码的一个重要体现，但不是全部。高质量代码具体还体现在代码可测试性、代码健壮性、代码高性能等等许多细节方面。

耦合性高低的衡量标准：

- `依赖性`：模块之间依赖尽量少
- `正交性`：模块之间重复功能尽量少
- `紧凑性`：模块暴露的方法和参数尽量少

实际上这3个指标大概分别对应着7大设计原则中的`迪米特法则`、`单一职责原则`、`接口隔离原则`等原则。

7大设计原则也就是高质量软件的编写原则，也印证了解耦是属于高质量代码的一部分体现。

**解耦的本质：减少系统需要维护的状态总数**

- 减少模块内部的状态数
- 缩小状态的作用域：状态越难被改变，可能存在的状态数就越少，例如将全局变量尽可能的转为局部变量、使用闭包、只允许使用指定方法改变状态；
- 模块间方法调用的单向依赖：调用其他模块方法目的基本都是为了改变对方的状态，如此对方的状态被耦合到了本模块，状态数翻倍
- 模块间数据调用的单向依赖：即单向数据流，与方法单向依赖一样，可以减少状态在两个模块中都存在，导致的状态数翻倍

## 设计原则

- [ ] [开闭原则]()
- [ ] [迪米特法则]()
- [ ] [里氏替换原则]()
- [ ] [依赖倒置原则]()
- [ ] [单一职责原则]()
- [ ] [接口隔离原则]()
- [ ] [合成复用原则]()

## 设计模式

> 弥补编程语言缺陷

### 架构型模式

- [ ] [MVC模式]()
- [ ] [MVP模式]()
- [ ] [MVVM模式]()
- [ ] [Widget模式]()
- [ ] [简单工厂模式]()
- [ ] [异步模块模式]()
- [ ] [同步模块模式]()

### 技巧型模式

- [ ] [链模式]()
- [ ] [委托模式]()
- [ ] [惰性模式]()
- [ ] [防抖模式]()
- [ ] [节流模式]()
- [ ] [参与者模式]()
- [ ] [等待者模式]()
- [ ] [简单模板模式]()
- [ ] [数据访问对象模式]()

### 23种经典模式

#### 创建型模式（5种）

- [ ] [建造者（Builder）模式]()
- [ ] [单例（Singleton）模式]()
- [ ] [原型（Prototype）模式]()
- [ ] [工厂方法（FactoryMethod）模式]()
- [ ] [抽象工厂（AbstractFactory）模式]()

#### 结构型模式（7种）

- [ ] [代理（Proxy）模式]()
- [ ] [桥接（Bridge）模式]()
- [ ] [外观（Facade）模式]()
- [ ] [适配器（Adapter）模式]()
- [ ] [装饰（Decorator）模式]()
- [ ] [享元（Flyweight）模式]()
- [ ] [组合（Composite）模式]()

#### 行为型模式（11种）

- [ ] [状态（State）模式]()
- [ ] [命令（Command）模式]()
- [ ] [策略（Strategy）模式]()
- [ ] [备忘录（Memento）模式]()
- [ ] [访问者（Visitor）模式]()
- [ ] [中介者（Mediator）模式]()
- [ ] [迭代器（Iterator）模式]()
- [ ] [观察者（Observer）模式]()
- [ ] [解释器（Interpreter）模式]()
- [ ] [模板方法（Template Method）模式]()
- [ ] [职责链（Chain of Responsibility）模式]()

## 参考资料

- <https://developer.aliyun.com/article/916743#slide-0>
- 在线运行：<https://tool.lu/coderunner/#>
- <https://www.imooc.com/article/335306>
- <https://github.com/studeyang/design-pattern/tree/master/src/designpattern/creation/factory/simple>
- <https://design-patterns.readthedocs.io/zh-cn/latest/creational_patterns/simple_factory.html>
