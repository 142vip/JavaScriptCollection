#### **什么是MemCache**

> memcached 是以LiveJournal旗下Danga Interactive 公司的Brad Fitzpatric 为首开发的一款软件。现在已成为mixi、hatena、Facebook、Vox、LiveJournal 等众多服务中提高Web应用扩展性的重要因素。许多Web 应用都将数据保存到RDBMS（关系型数据库管理系统）中，应用服务器从中读取数据并在浏览器中显示。但随着数据量的增大、访问的集中，就会出现RDBMS 的负担加重、数据库响应恶化、网站显示延迟等重大影响。memcached 是高性能的分布式内存缓存服务器。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web 应用的速度、提高可扩展性。

#### **Cache如何提高缓存**

由于硬件技术的限制，我们可以制造出容量很小但很快的存储器，也可以制造出容量很大但很慢的存储器，但不可能制造出访问速度又快容量又大的存储器。基于这个原理，我们用不同的存储器来进行不同的存储功能；按照离CPU由近到远的顺序，存储器的分类依次是CPU寄存器、Cache、内存、硬盘，越靠近CPU的存储器容量越小但访问速度越快；

cpu对各种存储器的访问速度比较：寄存器（ns）>cache（几十ns）>内存（几百ns）>硬盘（ms）

cache高速缓冲存储器，其中复制了频繁使用的数据以利于快速访问。
存储器的高速缓冲存储器存储了频繁访问的RAM位置的内容及这些数据项的存储地址。当处理器引用存储器中的某地址时，高速缓冲存储器便检查是否存有该地址。如果存有该地址，则将数据返回处理器;如果没有保存该地址，则进行常规的存储器访问。一级Cache更靠近CPU执行单元，二级Cache更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB。再大的话，就满足不了速度要求了，造成计算机的处理速度变慢；

#### **memcache特点**

- Memcache是一个高性能的分布式的内存对象缓存系统；
- 通过在内存里维护一个统一的巨大的hash表，能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。
- 简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
- 本质上就是一个内存key-value数据库，
- 不支持数据的持久化，服务器关闭之后数据全部丢失

#### **memcache常用操作**

##### cache数据写入操作

  > Set、add、replace三个方法，返回值均为boolean；

- **set**	cache服务器存在同样的key，则替换之；
- **add**	如果cache服务器存在同样key，则返回false；
- **Replace**	如果cache服务器不存在同样key，则返回false
- **append** 	命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。
- **prepend** 	命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。

##### cache数据读取操作方法

- **get方法**   从cache服务器获取一个数据如果写入时是压缩的或序列化的，则get的返回会自动解压缩及反序列化
- **getMulti方法**    从cache服务器获取一组数据,get方法的数组实现，输入参数keys是一个key数组

##### 辅助命令

- **stats 命令**   用于返回统计信息例如 PID(进程号)、版本号、连接数等。
- **flush_all命令**   用于清理缓存中的所有 key=>value(键=>值) 对

#### 缓存常见问题

##### 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

解决方法：

- 对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

- 也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

#####  缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，缓存在某一时刻同时失效，**请求全部转发到DB，DB瞬时压力过重雪崩。**

解决方法：
缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。
    

##### 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来， 这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

解决方法：

- 使用互斥锁(mutex key)；
- "永远不过期"；
-  资源保护；